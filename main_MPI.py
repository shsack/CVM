import numpy as np
import os
import csv
from mpi4py import MPI
import multiprocessing as mp
from functools import partial
import glob

exe_name = "heisenberg"


def split_data(size, data):

    """Split the data on the MPI ranks"""

    n = len(data) // size
    return [data[i:i + n] for i in range(0, len(data), n)]


def run_exe(omega, N, eta, max_iter, tol, i, j, maxm, cut):

    """Run the executable generated by the C++ file"""

    os.system("./{} {} {} {} {} {} {} {} {} {}".format(exe_name, omega, N, eta, max_iter, tol, i, j, maxm, cut))


# MPI setup
comm = MPI.COMM_WORLD
rank = comm.Get_rank()  # Identification number of node
size = comm.Get_size()  # Number of nodes

# Define data
omega = np.linspace(start=-1., stop=4., num=200, dtype=float)

# Split the data in the zeroth node
if rank == 0:
    data_split = split_data(size, omega)
else:
    data_split = None

# Scatter data from zeroth node onto other nodes and do the calculation in each node
data_in_node = comm.scatter(data_split, root=0)

# Split running of exe in each rank on CPUs
p = mp.Pool(mp.cpu_count())
run_exe_ = partial(run_exe, N=10, eta=0.05, max_iter=50, tol=1E-5, i=1, j=1, maxm=20, cut=1E-6)
p.map(run_exe_, data_in_node)


correlator = []

# Make sure that all ranks have finished
comm.gather(0, root=0)

# Sort the filenames numerically
filenames = sorted([(element[len(exe_name)+6:-4]) for element in glob.glob('data/*.txt')], key=float)

if rank == 0:

    # Read result form files and delete intermediate files
    for filename in filenames:

        name = 'data/{}_{}.txt'.format(exe_name, filename)
        f = open(name)
        correlator.append(float(f.readline()))
        f.close()
        os.remove(name)

    # Save data in final file
    f = open('data/{}_data.csv'.format(exe_name), 'w')
    out = csv.writer(f, delimiter=' ')
    out.writerows(zip(omega, correlator))
    f.close()

